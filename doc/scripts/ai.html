<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<!--
----	(c) Copyright 2002-2003 by Lutz Sammer

----    This program is free software; you can redistribute it and/or modify
----    it under the terms of the GNU General Public License as published by
----    the Free Software Foundation; only version 2 of the License.
----
----    This program is distributed in the hope that it will be useful,
----    but WITHOUT ANY WARRANTY; without even the implied warranty of
----    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
----    GNU General Public License for more details.
----
----    You should have received a copy of the GNU General Public License
----    along with this program; if not, write to the Free Software
----    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
----    02111-1307, USA.
-->
    <title>Stratagus Configuration Language Description: Artificial Intelligence(AI)</title>
    <meta http-equiv="Content-Type" content="text/html; CHARSET=iso-8859-1">
    <meta name="Author" content="johns98@gmx.net">
    <meta name="Keyword" content="ccl,ai,artificial intelligence">
    <meta name="Description" content="">
</head>
<body>
    <h1>Stratagus Configuration Language Description: Artificial Intelligence
    (AI)</h1>
<hr><pre width=80>
         _________ __                 __                               
        /   _____//  |_____________ _/  |______     ____  __ __  ______
        \_____  \\   __\_  __ \__  \\   __\__  \   / ___\|  |  \/  ___/
        /        \|  |  |  | \// __ \|  |  / __ \_/ /_/  >  |  /\___ \ 
       /_______  /|__|  |__|  (____  /__| (____  /\___  /|____//____  >
               \/                  \/          \//_____/            \/ 
    ______________________                           ______________________
			  T H E   W A R   B E G I N S
	   Stratagus - A free fantasy real time strategy game engine
</pre>
<p><b>(C) Copyright 2002-2003 by The Stratagus Project. Distributed under the
<a href="../gpl.html">"GNU General Public License"</a></b>
<hr>
<a href="../stratagus.html">Stratagus</a> 
<a href="../readme.html">Readme</a> 
<a href="../faq.html">FAQ</a> 
<a href="ccl.html">CCL</a> 
<a href="unittype.html">PREV</a> 
<a href="config.html">NEXT</a> 
<a href="ccl-index.html">Index</a> 
<hr>
<a href="#define-ai">define-ai</a>
<a href="#define-ai-action">define-ai-action</a>
<a href="#define-ai-helper">define-ai-helper</a>
<a href="#define-ai-player">define-ai-player</a>
<a href="pud.html#define-ai-wc-names">define-ai-wc-names</a>
<a href="#ai:adhoc-force">ai:adhoc-force</a>
<a href="#ai:check-force">ai:check-force</a>
<a href="#ai:clear-force">ai:clear-force</a>
<a href="#ai:compute-gauges">ai:compute-gauges</a>
<a href="#ai:debug">ai:debug</a>
<a href="#ai:debug-gauges">ai:debug-gauges</a>
<a href="#ai:debug-player">ai:debug-player</a>
<a href="#ai:dump">ai:dump</a>
<a href="#ai:evaluate-force-cost">ai:evaluate-force-cost</a>
<a href="#ai:force">ai:force</a>
<a href="#ai:force-active">ai:force-active</a>
<a href="#ai:force-complete">ai:force-complete</a>
<a href="#ai:force-empty">ai:force-empty</a>
<a href="#ai:force-go-home">ai:force-go-home</a>
<a href="#ai:force-list">ai:force-list</a>
<a href="#ai:force-role">ai:force-role</a>
<a href="#ai:force-transfer">ai:force-transfer</a>
<a href="#ai:get-force">ai:get-force</a>
<a href="#ai:get-gauge">ai:get-gauge</a>
<a href="#ai:get-race">ai:get-race</a>
<a href="#ai:get-sleep-cycles">ai:get-sleep-cycles</a>
<a href="#ai:get-unittype-force">ai:get-unittype-force</a>
<a href="#ai:hotspot-attack-with-force">ai:hotspot-attack-with-force</a>
<a href="#ai:idle">ai:idle</a>
<a href="#ai:need">ai:need</a>
<a href="#ai:own-force">ai:own-force</a>
<a href="#ai:player">ai:player</a>
<a href="#ai:research">ai:research</a>
<a href="#ai:restart">ai:restart</a>
<a href="#ai:script">ai:script</a>
<a href="#ai:set">ai:set</a>
<a href="#ai:set-auto-attack">ai:set-auto-attack</a>
<a href="#ai:set-collect!">ai:set-collect!</a>
<!-- <a href="#ai:set-hotspot-ray">ai:set-hotspot-ray</a> -->
<a href="#ai:set-reserve!">ai:set-reserve!</a>
<a href="#ai:sleep">ai:sleep</a>
<a href="#ai:timed-wait-force">ai:timed-wait-force</a>
<a href="#ai:upgrade-to">ai:upgrade-to</a>
<a href="#ai:wait">ai:wait</a>
<a href="#ai:wait-force">ai:wait-force</a>

<hr>
<h2>Intro - Introduction to AI functions and variables</h2>

Everything around the control of the Stratagus AI.

<h2>How does it work</h2>

AI in Stratagus is script based. Each AI player keeps executing scheme-like scripts.
There are two kinds of scripts : 
<ul>
  <li>The main script. It starts buildings, upgrades, ...</li>
  <li>The action/reaction scripts. They are started by the AI engine, under certain condition.<br>
  They can use the gauge mecanism to decide which types and how many units to send, ... See <a href="#ai:get-gauge">ai:get-gauge</a> for details.
  </li>
</ul>
Scripts can arrange and control units using forces : <br>
A script can ask for some type of unit in a force (using <a href="#ai:force">ai:force</a>), 
and then wait for them to be ready (using <a href="#ai:wait-force">ai:wait-force</a>).<br>
Then it can send them to attack ( <a href="#ai:hotspot-attack-with-force">ai:hotspot-attack-with-force</a> ) 
or back home ( <a href="#ai:force-go-home">ai:force-go-home</a> ).
<br>
Each action/reaction script has a specific force which keeps all its units. ( see <a href="#ai:own-force">ai:own-force</a> )<br>
<br>
The force 0 is a special case : it holds all the unassigned units, and is used to fill other forces. 
( when needed, units are transfered from force 0 to others ). Attacker units in force 0 won't be used for attacks<br>
Forces from 1 to 3 are also special : They are used as the attack reserve. 
Attack forces will only be created using units available in those forces.<br>
<br>
The main script is responsible for setting minimums for the forces 0 and 1. This will influence the balance
between defend and attack for an AI player.<br>

<br>

<h2>Functions</h2>
<a name="define-ai"></a>
<h3>(define-ai name race class script)</h3>

This defines how a special AI works. Each level can use his own AI definition.

<dl>
<dt>name</dt>
<dd>Unique name of this AI definitions.
</dd>
<dt>race</dt>
<dd>Name of the race for what this definition can be used, if the definition
    can be used for any race use "*".
</dd>
<dt>class</dt>
<dd>Class name of this definition. Used to chooce the AI for computer players.
The puds contains numbers which are mapped by the C table AiTypeWcNames into
internal names. Some common used names are "passive", "land-attack",
"sea-attack", "air-attack".
</dd>
<dt>script</dt>
<dd>A list of scheme statements executed one after another.<p>
<code>( (code-1) (code-2) ... (code-n) )</code><p>
code-1 can be any valid scheme statement. Currently each second this
statement is executed, if the statement returns not #t, than the next
time the next statement is executed. No statement should use more than 3 ms.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Defines the passive computer AI, which does nothing.
(define-ai "passive-ai" "*" "passive"
  '((ai:sleep	10000)
  (ai:restart) ))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="define-ai-action"></a>
<h3>(define-ai-action '(flags...) '( (name create-force-lambda drive-action-script) ... ))</h3>

This defines an action which can be used for attacking of defending.


<dl>
<dt>flags</dt>
<dd>Can be defense, attack or both. The action will be used for attacking or defending, depending on the flags set.<br>
A defense script will be thrown when a computer controlled unit 
which is not attacking ( i.e. units in force 0 ) is attacked. 
In that case, the hotspot (see <a href="#get-gauge">get-gauge</a>)
will be set to the position of the attacker<br>
Attack scripts are evaluated from time to time using random enemy unit as target (hotspot). 
When an evaluation looks good, the corresponding script is started. 
( An evaluation "looks good" if units are ready to be sent and the value of the attacked area is interesting. ) 
</dd>
<dt>name</dt>
<dd>Unique name of this AI action.
</dd>
<dt>create-force-lambda</dt>
<dd>Name of a scheme lambda which will be used to create the force. 
It will receive one parameter : the second parameter of define-ai-action. The hotspot (see <A HREF='#get-gauge-value'>get-gauge-value</A> )  will be set on the area the AI needs to defend or attack.
It must returns a int value indicating wether the action can be started : 
<ul>
<li>-1 if the action should not occur at all,
<li>0 if the action is ready to start,
<li>&gt;0 if the force may be ready in the future. ( see <A HREF='#evaluate-force-cost'>evaluate-force-cost</A> ).
</ul>
</dd>
<dt>drive-action-script</dt>
<dd>Name of a scheme script which be used to "drive" the attack ( or defense). The script must have the same form as those defined by <A href="#define-ai">define-ai</A>.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; This simple scheme lambda ask for 10 grunt and 20 troll...
    ;; the script parameter could be used to tune those values.
(define create-force-lambda 
  (lambda (script)
    (begin
        ;; Clear the action's force
      (ai:clear-force (ai:own-force))	
        ;; update the force to ask for units
      (ai:force-list (cons (ai:own-force) '(unit-grunt 10 unit-troll 20)))
        ;; take units from force 0...
      (ai:force-complete (ai:own-force))
        ;; return an evaluation of what is missing ( will return -1 if can't build required units )
      (ai:evaluate-force-cost (ai:own-force)) )))

    ;; this script just send the force to attack at the current hotspot.
(define simple-attack-script
  '(
        ;; send whole force to attack
     (ai:hotspot-attack-with-force (ai:own-force))
        ;; wait until force is totally idle...
     (if (ai:force-active (ai:own-force))
        (ai:idle))
	;; Send force to home and release it ( so that units can be reused )
     (begin
        ;; Send units home,
        ;; and forget about them.
        (ai:force-go-home (ai:own-force))
        (ai:clear-force (ai:own-force))) ))

    ;; describe a new action which will be available to the AI.
(define-ai-action '(attack)
  '(
      (
          ;; name
	dummy-attack
	  ;; create-force lambda
	create-force-lambda
	  ;; script to use
	simple-attack-script
      )
        ;; You could add some internal stuffs there, and use it in create-force-lambda.
      ;; ...
))

</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="define-ai-helper"></a>
<h3>(define-ai-helper (list))</h3>

The AI is complete configurable, nothing is hardcoded. The AI knows nothing
about any units without this table. This table defines F.E. what unit can build
and what they can build and many other things that the AI must know.


<dl>
<dt>list</dt>
<dd>A list of features:
 <ul>
 <li><code>(list 'build 'builder 'building-1 ... 'building-n)</code>
  <dl>
  <dt>builder</dt>
  <dd>Name of the unit-type that can build.
  </dd>
  <dt>building-1</dt>
  <dt>building-n</dt>
  <dd>Names of the unit-types that can be builded by the builder.
  </dd>
  </dl>
  <b>Note:</b> If more units can build the same buildings you need the same list
	for all units.
 <li><code>(list 'train 'trainer 'unit-1 ... 'unit-n)</code>
  <dl>
  <dt>trainer</dt>
  <dd>Name of the unit-type that can train the units.
  </dd>
  <dt>unit-1</dt>
  <dt>unit-n</dt>
  <dd>Names of the unit-types that can be trained by the trainer.
  </dd>
  </dl>
  <b>Note:</b> If more units can train the same unit you need the same list
	for all units.
 <li><code>(list 'upgrade 'unit 'upgraded-unit-1 ... 'upgraded-unit-n)</code>
  <dl>
  <dt>unit</dt>
  <dd>Name of the unit-type that can be upgraded.
  </dd>
  <dt>upgraded-unit-1</dt>
  <dt>upgraded-unit-n</dt>
  <dd>Names of the unit-types to that the unit can be upgraded.
  </dd>
  </dl>
 <li><code>(list 'research 'researcher 'upgrade-1 ... 'spell-n)</code>
  <dl>
  <dt>researcher</dt>
  <dd>Name of the unit-type that can reasearch upgrades or spells.
  </dd>
  <dt>upgrade-1</dt>
  <dt>spell-n</dt>
  <dd>Names of the upgrades or spells that can be researched by the researcher.
  </dd>
  </dl>
 <li><code>(list 'repair 'worker 'unit-1 ... 'unit-n)</code>
  <dl>
  <dt>worker</dt>
  <dd>Name of the unit-type that can repair other units.
  </dd>
  <dt>unit-1</dt>
  <dt>unit-n</dt>
  <dd>Names of the unit-types that can be repaired by the worker.
  </dd>
  </dl>
  <b>Note:</b> If more units can repair the same units you need the same list
	for all units.
 <li><code>(list 'equiv 'unit 'unit-1 ... 'unit-n)</code>
  <dl>
  <dt>unit</dt>
  <dd>Name of the unit-type that have equilvalent units.
  </dd>
  <dt>unit-1</dt>
  <dt>unit-n</dt>
  <dd>Names of the unit-types that can be uses by the AI equivalent.
  </dd>
  </dl>
 <li><code>(list 'unit-limit 'unit 'resource)</code>
  <dl>
  <dt>unit</dt>
  <dd>Name of the unit-type that must be produced to reduce the unit limit.
  </dd>
  <dt>resource</dt>
  <dd>Name of the resource producing the shortage.
  </dd>
  </dl>
  <i>I think we should swap the arguments: 'resource 'unit.</i>
 </ul>
</dd>
</dl>

<h4>Example</h4>

A minimal AI helper definition:

<pre>
(define-ai-helper
  (list 'build 'unit-peasant 'unit-farm)
  (list 'train 'unit-town-hall 'unit-peasant)
  (list 'upgrade 'unit-town-hall 'unit-keep)
  (list 'research 'unit-human-blacksmith 'upgrade-sword1)
  (list 'repair 'unit-peasant 'unit-town-hall)
  (list 'unit-limit 'unit-farm 'food)
  (list 'unit-equiv 'unit-town-hall 'unit-keep))
</pre>

<p>A peasant can build a farm.
<p>The town hall can train a peasant.
<p>A town hall can be upgraded to a keep.
<p>The blacksmith can reasearch the upgrade sword1.
<p>A peasant can repair the town hall.
<p>To fix the food shortage the AI must build farms.
<p>For the AI is a keep equivalent to a town hall.

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="define-ai-player"></a>
<h3>(define-ai-player (list ...))</h3>

Define an AI player. (NOT SUPPORTED)


<dl>
<dt></dt>
<dd>
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; FIXME:
FIXME:
    (define-ai-player (list ...))
</pre>

<h4>Not Used</h4>

<a name="ai:adhoc-force"></a>
<h3>(ai:adhoc-force requirements unittypes)</h3>

Create a force to respond to the given requirements. 
The force updated is (<a href="#ai:own-force">ai:own-force</a>).<br>
Force is populated with available units.<br>
If such a force cannot be created, return False. True otherwise.

<dl>
<dt>requirements</dt>
<dd>A list of land/sea/air power that the force must have.
</dd>
<dt>unittypes</dt>
<dd>A list of unittypes which can be used to create the force.
The force will be created using a subset (or all) of those unittypes.<br>
If a unittype is given twice ( or more... ), it will increase 
its representation in the resulting force. 
</dl>

<h4>Example</h4>

<pre>
      ;; Create a force composed of grunt and trolls to respond to enemy forces on the hotspot    
    (if 
      (ai:adhoc-force 
        (list 
	  (ai:get-gauge 'enemy-hotspot-ground-force)
          (ai:get-gauge 'enemy-hotspot-sea-force)
          (ai:get-gauge 'enemy-hotspot-air-force))
	(unittype-grunt unittype-troll))
        ;; Force OK ?
      (ai:hotspot-attack-with-force (ai:own-force))
        ;; Not ok ? arg.
      (writes nil "Can't defend with grunts and trolls!"))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:check-force"></a>
<h3>(ai:check-force force)</h3>

Check if a force is ready.


<dl>
<dt>force</dt>
<dd>Number of the force to which the units should belong. 0 - 9 is currently
supported.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Force 0 is build with one footman. When the force is ready, sleep for
    ;; 500 frames.
    (ai:force 0 'unit-footman 1)
    (if (ai:check-force 0) (ai:sleep 500))
</pre>

<h4>Not Used</h4>

<a name="ai:clear-force"></a>
<h3>(ai:clear-force force)</h3>

Reset a force. ( set all needs to 0, unassign all units. ) 

<dl>
<dt>force</dt>
<dd>Number of the force to clear. 0 - 9 is currently
supported.
</dd>
</dl>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:debug"></a>
<h3>(ai:debug flag)</h3>

Enable or disable the debug output of the AI script execution.


<dl>
<dt>flag</dt>
<dd>If #t enables printing of the AI commands, if #f disables it.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Prints now the commands of this computer player.
    (ai:debug #t)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:debug-gauges"></a>
<h3>(ai:debug-gauges)</h3>

Dump all the gauges on the stdout.

<h4>Example</h4>

<pre>
    ;; Prints all the gauges on stdout...
    (ai:debug-gauges)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:debug-player"></a>
<h3>(ai:debug-player 1 2 3 ...)</h3>

Activate dump of AI forces and strategy on stdout.<br>
Parameters are player number, or 'self, for thisplayer.<br>
'none will stop all AI debug output.

<h4>Example</h4>

<pre>
    (ai:debug-player 'self)
</pre>

<h4>Used</h4>

During the game...

<a name="ai:dump"></a>
<h3>(ai:dump)</h3>

Dump some AI debug information.


<h4>Example</h4>

<pre>
    ;; Prints out some debug information.
    (ai:dump)
</pre>

<h4>Not Used</h4>

<a name="ai:evaluate-force-cost"></a>
<h3>(ai:evaluate-force-cost force)</h3>

Evaluate ressource and time needed to complete a force.
The returned value is compatible with the one returned by an action lambda 
( see <a href="#define-ai-action">define-ai-action</a> ) :
<ul>
  <li>-1 : the force can't be completed</li>
  <li>0 : the force is ready</li>
  <li>&gt;0 : the force can be completed ( the higher the harder/longer )</li>
</ul>

<dl>
<dt>force</dt>
<dd>The force to evaluate.
</dd>
</dl>

<h4>See also</h4>

<a href="#define-ai-action">define-ai-action</a>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force"></a>
<h3>(ai:force force unit-type-1 count-1 ... unit-type-N count-N)</h3>

Define a force, what and how many units should belong to a force. Up to 10
forces are currently supported.
<br>
Force 0 is currently fixed to be the defence force. Send to a building or
unit under attack.
<br>
If there are any unassigned units of the requested unit-type, than they are
assigned to the force.
<br>
Note: The low-level didn't support the reduce of a force.


<dl>
<dt>force</dt>
<dd>Number of the force to which the units should belong. 0 - 9 is currently
supported.
</dd>
<dt>unit-type-1</dt>
<dt>unit-type-N</dt>
<dd>Unit-type that should be in the force. Currently only mobile (trained) units
are allowed.
</dd>
</dl>
<dt>count-1</dt>
<dt>count-N</dt>
<dd>How many of this units should be in the force.
</dd>
</dl>

<i>The unit-types should be build in a fixed order. From left to right? or from
each unit-type one after the other?</i>

<h4>Example</h4>

<pre>
    ;; First the force 0 is filled up with 4 footmans and 5 bowmans, after this
    ;; force 1 is filled with 3 footmans and 2 bowmans.
    (ai:force 0 'unit-footman 4 'unit-bowman 5)
    (ai:force 1 'unit-footman 3 'unit-bowman 2)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-active"></a>
<h3>(ai:force-active force)</h3>

Return #t if the force is active, #f otherwise. A force is active while at least one units is not standing.

<i>
An empty force is not active.
</i>

<dl>
<dt>force</dt>
<dd>Number of the force to check. 0 - 9 is currently supported.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Wait until the force has completed attack.
    (if (ai:force-active (ai:own-force))
    	(ai:idle))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-complete"></a>
<h3>(ai:force-complete force)</h3>

Complete a force using units from reserve.<br>
If the force created is an attack force, only units from attack reserve will used ( force 1 ). 
For defense force, all reserve forces will be used ( force 0 and 1 )  

<dl>
<dt>force</dt>
<dd>Force to complete. 0 - 9 is currently supported.
</dd>
</dl>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-empty"></a>
<h3>(ai:force-empty force)</h3>

Return #t if the force is empty ( no unit ), #f otherwise.

<dl>
<dt>force</dt>
<dd>Number of the force to check. 0 - 9 is currently supported.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Wait until the force is completely destroyed. ( possibly hand forever... )
    (if (not (ai:force-empty (ai:own-force)))
    	(ai:idle))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-go-home"></a>
<h3>(ai:force-go-home force)</h3>

Send all units of the force to home. 

<i>
Home means in fact the player start position. This should be improved.
</i>

<dl>
<dt>force</dt>
<dd>Number of the force to send back home. 0 - 9 is currently supported.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Wait until the force has finished attacking.
    (if (ai:force-active (ai:own-force))
    	(ai:idle))
    ;; Send units to home...
    (ai:force-go-home (ai:own-force))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-list"></a>
<h3>(ai:force-list '(force unittype count unittype count ... ))</h3>

Same as <a href="#ai:force">ai:force</a>, but all arguments are stored in a list. 

<h4>See also</h4>

<a href="#ai:force">ai:force</a>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-role"></a>
<h3>(ai:force-role force role)</h3>

Define the role of a force.


<dl>
<dt>force</dt>
<dd>Number of the force to which the units should belong. 0 - 9 is currently
supported.
</dd>
<dt>role</dt>
<dd>The role of the force.  Can be either 'attack or 'defend'.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Sets the role of force 0 to attack.
    (ai:force-role 0 'attack)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:force-transfer"></a>
<h3>(ai:force-transfer source destination)</h3>

Move units from the source force to fill the destination force.
No move will be done if the destination force is already full.

<dl>
<dt>source</dt>
<dd>Number of the source force. 0 - 9 is currently supported.
</dd>
<dt>destination</dt>
<dd>Number of the destination force. 0 - 9 is currently supported.
</dd>
</dl>

<h4>Not Used</h4>

<a name="ai:get-force"></a>
<h3>(ai:get-force force)</h3>

Returns the force requirements as a list of unittype and count.

<dl>
<dt>force</dt>
<dd>Number of the force. 0 - 9 is currently supported.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Make a carbon copy of force 0 into force 1...
    (ai:force-list (cons 1 (ai:get-force 0)))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:get-gauge"></a>
<h3>(ai:get-gauge gauge)</h3>

Returns the value of a given gauge.<br>
Each gauge is identified by a name. Available gauges are :
<ul>
<li>Scores<ul>		    
		<li>allied-score enemy-score self-score
</li>		
</ul></li><li>ressources<ul>
		<li>gold-hotspot gold-map wood-hotspot wood-map oil-hotspot oil-map
</li>		
</ul></li><li>fire power over sea<ul>				
		<li>allied-hotspot-sea-fire enemy-hotspot-sea-fire self-hotspot-sea-fire
</li>		
		<li>allied-map-sea-fire enemy-map-sea-fire self-map-sea-fire
</li>		
</ul></li><li>fire power on ground<ul>		
		<li>allied-hotspot-ground-fire enemy-hotspot-ground-fire self-hotspot-ground-fire
</li>		
		<li>allied-map-ground-fire enemy-map-ground-fire self-map-ground-fire
</li>				
</ul></li><li>fire power on air<ul>		
		<li>allied-hotspot-air-fire enemy-hotspot-air-fire self-hotspot-air-fire
</li>		
		<li>allied-map-air-fire enemy-map-air-fire self-map-air-fire
</li>		
</ul></li><li>detectors<ul>
		<li>allied-hotspot-detectors enemy-hotspot-detectors  self-hotspot-detectors
</li>		
		<li>allied-map-detectors enemy-map-detectors self-map-detectors
</li>		
</ul></li><li>fire power from sea<ul>		
		<li>allied-hotspot-sea-force enemy-hotspot-sea-force self-hotspot-sea-force
</li>		
		<li>allied-map-sea-force enemy-map-sea-force self-map-sea-force
</li>		
</ul></li><li>fire power from ground<ul>		
		<li>allied-hotspot-ground-force enemy-hotspot-ground-force self-hotspot-ground-force
</li>		
		<li>allied-map-ground-force enemy-map-ground-force self-map-ground-force
</li>		
</ul></li><li>fire power from air<ul>
		<li>allied-hotspot-air-force enemy-hotspot-air-force self-hotspot-air-force
</li>		
		<li>allied-map-air-force enemy-map-air-force self-map-air-force
</li>
</ul></li><li>points value of units on the sea<ul>		
		<li>allied-hotspot-sea-value enemy-hotspot-sea-value self-hotspot-sea-value
</li>		
		<li>allied-map-sea-value enemy-map-sea-value self-map-sea-value
</li>		
</ul></li><li>points value of units on ground<ul>
		<li>allied-hotspot-ground-value enemy-hotspot-ground-value self-hotspot-ground-value
</li>		
		<li>allied-map-ground-value enemy-map-ground-value self-map-ground-value
</li>		
</ul></li><li>points value of units on the sky<ul>		
		<li>allied-hotspot-air-value enemy-hotspot-air-value self-hotspot-air-value 
</li>		
		<li>allied-map-air-value enemy-map-air-value self-map-air-value 
</li>
</ul></li><li>invisibles units<ul>
		<li>allied-hotspot-invisibles enemy-hotspot-invisibles self-hotspot-invisibles
</li>		
		<li>allied-map-invisibles enemy-map-invisibles self-map-invisibles
</li>
</ul></ul><br>

<i>Gauges about ressources are not correctly computed.</i>

<i>To get the individual value of an unit type in the fire power gauges, use <a href="#ai:get-unittype-force">ai:get-unittype-force</a></i>  

<dl>
<dt>gauge</dt>
<dd>Identifier of the gauge.
</dd>
</dl>

<h4>See also</h4>

<a href="#ai:get-unittype-force">ai:get-unittype-force</a>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:get-race"></a>
<h3>(ai:get-race)</h3>

Get the race of the current AI player.


<h4>Example</h4>

<pre>
    ;; Returns the race name of the current AI player.
    (ai:get-race)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:get-sleep-cycles"></a>
<h3>(ai:get-sleep-cycles)</h3>

Get the number of cycles to sleep.


<h4>Example</h4>

<pre>
    ;; Returns the number of cycles to sleep.
    (ai:get-sleep-cycles)
</pre>

<h4>Not Used</h4>

<a name="ai:get-unittype-force"></a>
<h3>(ai:get-unittype-force unittype)</h3>

Return the contribution of a given unittype in gauge computation.

<h4>Example</h4>

The following code create and send some grunt to attack on the hotspot.
<pre>
    ;; Calculate the number of grunt to sent ....
    (let      
      (( grunt-nb 
	(quotient 
	  (get-gauge 'enemy-hotspot-ground-force)
	  (get-unittype-force 'unittype-grunt))))
	;; create a force with the accurate number of grunt  
      (ai:force (ai:own-force) unittype-grunt grunt-nb)
      (ai:wait-force (ai:own-force))
      (ai:hotspot-attack-with-force (ai:own-force)))	
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<h4>See also</h4>

<a href="#ai:get-gauge">ai:get-gauge</a>

<a name="ai:hotspot-attack-with-force"></a>
<h3>(ai:attack-with-force force)</h3>

Attack the opponent with a force. The attack place is taken from the hotspot position.

<dl>
<dt>force</dt>
<dd>Number of the force to which the units should belong. 0 - 9 is currently
supported.22
</dd>
</dl>

<i>The force isn't moved as unit, faster units attacks first, than later the
slower units will attack.</i>

<h4>Example</h4>

<pre>
    ;; Force 0 is built with one footman. The script continues processing, if the
    ;; footman is ready trained. Now attack the opponent with force 0.
    (ai:force 0 'unit-footman 1)
    (ai:wait-force 0)
    (ai:hotspot-attack-with-force 0)
</pre>

<h4>See also</h4>

<a href="#ai:attack-with-force">ai:attack-with-force</a>

<a href="#ai:force-go-home">ai:force-go-home</a>


<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:idle"></a>
<h3>(ai:idle)</h3>

Just return #f, to suspend AI script execution.

<h4>Example</h4>

<pre>
    ;; Wait while the force is active
  (if (ai:force-active (ai:own-force))
  	(ai:idle))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:need"></a>
<h3>(ai:need unit-type)</h3>

Tells the AI that it should have an unit of this unit-type. The AI builds or
trains units in this order of the ai:set/ai:need commands. If the unit or an
equivalent unit already exists, the AI does nothing. If the unit is lost, it is
automatic rebuild. If the units are requested in wrong order, the AI could 
hang up. Resources are collected automatic and farms are automatic build, but
additional could be requested.


<dl>
<dt>unit-type</dt>
<dd>Name of the unit-type required.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; The great hall must be build before a barrack.
  (ai:need (unit-type 'unit-great-hall))
  (ai:need (unit-type 'unit-barrack))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:own-force"></a>
<h3>(ai:own-force)</h3>

Return the number of the force which is dedicated to the currently executing AI script.

<h4>Example</h4>

<pre>
    ;; Require a grunt in the script's force
  (ai:force (ai:own-force) 'unittype-grunt 1 )
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:player"></a>
<h3>(ai:player)</h3>

Return the player of the running AI.


<h4>Example</h4>

<pre>
    ;; Returns the player of the running AI.
    (ai:player)
</pre>

<h4>Not Used</h4>

<a name="ai:research"></a>
<h3>(ai:research upgrade)</h3>

Let the AI research an upgrade, upgrades are reseached in command order.
And automatic researched if lost. Building orders have a higher priority.
The script writer is responsible for the correct order. If wrong the
AI could hang up.


<dl>
<dt>upgrade</dt>
<dd>Upgrade name to be researched.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Research a better armor for land units.
    (ai:research 'upgrade-shield1)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:restart"></a>
<h3>(ai:restart)</h3>

Restart with the main AI script. Could be used as longjmp for the AI
scripts.


<h4>Example</h4>

<pre>
    ;; A endless script doing nothing.
(define-ai "passive" "*" "passive"
  '( (ai:sleep   10000)
     (ai:restart) ))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:script"></a>
<h3>(ai:script script)</h3>

Execute a new script, can be used for loops, subroutines. But this must be
handled by the user.


<dl>
<dt>script</dt>
<dd>A list of AI commands. Executed one after the other.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; An example with a for ever loop. Wait for force 1 ready (all units trained),
    ;; than attack with the force 1. This is done endless.
(define attack-endloop
  '((ai:with-force 1)
    (ai:attack-with-force 1)
    (ai:script attack-endloop) ))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:set"></a>
<h3>(ai:set unit-type count)</h3>

This ai:need with a number. Tells the AI that it should have a specified number
of an unit of this unit-type. The AI builds or trains units in this order of
the ai:set/ai:need commands. If the unit or an equivalent unit already exists,
the AI does nothing. If the units are lost, they are automatic rebuild. If the
units are requested in wrong order, the AI could hang up. Resources are
collected automatic and farms are automatic build, but additional could be
requested. In the opposite to ai:need, which always inserts a request, ai:set
modifies the last request to the new number.


<dl>
<dt>unit-type</dt>
<dd>Name of the unit-type(s) required.
</dd>
<dt>count</dt>
<dd>Number of unit-types(s) required.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Request two peons.
    (ai:set 'unit-peon 2)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:set-auto-attack"></a>
<h3>(ai:set-auto-attack flag)</h3>

Enable or disable the automatic start of attack scripts.<br>
This is usefull to prevent AI from trying to attack when it can only
produce simple units...

<dl>
<dt>flag</dt>
<dd>#t will active automatic attack, #f disable it...
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; To make an air AI attack only when it can send flyers...
    (ai:set-auto-attack #f)
    
    ;; ... let's develop
    
    ;; Create the attack reserve
    (ai:force 1 'unit-dragon 2)
    
    ;; Wait until it's ready
    (ai:wait-force 1)
    
    ;; Then start auto-attack.    
    (ai:set-auto-attack #t)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:set-collect!"></a>
<h3>(ai:set-collect! #(time gold wood oil ore stone coal))</h3>

Set AI player resource collect percent.


<dl>
<dt>time</dt>
<dd>Time in game cycles.
</dd>
<dt>gold</dt>
<dd>Gold resource.
</dd>
<dt>wood</dt>
<dd>Wood resource.
</dd>
<dt>oil</dt>
<dd>Oil resource.
</dd>
<dt>ore</dt>
<dd>Ore resource.
</dd>
<dt>stone</dt>
<dd>Stone resource.
</dd>
<dt>coal</dt>
<dd>Coal resource.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Set the collect percent to 50% gold and 50% wood.
    (ai:set-collect! #(0  50 50 0  0 0 0))
</pre>

<h4>Not Used</h4>

<a name="ai:set-reserve!"></a>
<h3>(ai:set-reserve! #( time gold wood oil ore stone coal))</h3>

Set AI player resource reserve.


<dl>
<dt>time</dt>
<dd>Time in game cycles.
</dd>
<dt>gold</dt>
<dd>Gold resource.
</dd>
<dt>wood</dt>
<dd>Wood resource.
</dd>
<dt>oil</dt>
<dd>Oil resource.
</dd>
<dt>ore</dt>
<dd>Ore resource.
</dd>
<dt>stone</dt>
<dd>Stone resource.
</dd>
<dt>coal</dt>
<dd>Coal resource.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Set all of the reserves to 0.
    (ai:set-reserve! #( 0  0 0 0  0 0 0))
</pre>

<h4>Not Used</h4>

<a name="ai:sleep"></a>
<h3>(ai:sleep frames)</h3>

Wait some frames, to let the opponent (you) recover.


<dl>
<dt>frames</dt>
<dd>How many frames (~1/30s) the AI shouldn't proceed with the script.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Wait 500 frames ~16s.
    (ai:sleep 500)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:timed-wait-force"></a>
<h3>(ai:timed-wait-force force frame)</h3>

Wait until a force is complete or a timer expires. ( as <a href="#ai:wait-force">ai:wait-force</a> does )

<dl>
<dt>force</dt>
<dd>Number of the force to which the units should belong. 0 - 9 is currently
supported.
</dd>
<dt>frame</dt>
<dd>Maximum number of frame to wait for the force
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Force 0 is build with one footman. The script continues processing, if the
    ;; footman is ready trained.
    
    ;; If the footman is not ready in the next 1000 frames, the ai is restarted 
    (ai:force 0 'unit-footman 1)
    (ai:timed-wait-force 0 1000)
    (if (not (ai:check-force 0))
    	;; Force not ready => restart !
	(ai:restart))
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:upgrade-to"></a>
<h3>(ai:upgrade-to unit-type)</h3>

Upgrade units to an improved type. You must give for each unit you want to
upgrade an upgrade command. The computer automatic searches which unit it
upgrades.


<dl>
<dt>unit-type</dt>
<dd>Unit type to that an unit should be upgraded.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Upgrade a town-hall to keep.
    (ai:upgrade-to 'unit-keep)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:wait"></a>
<h3>(ai:wait type)</h3>

Waits until the *first* request of this unit-type is completed.
Don't forget to request an unit-type, before you wait on it.


<dl>
<dt>type</dt>
<dd>Wait for this unit type.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Proceed only if a peasant is ready.
    (ai:need 'unit-peasant)
    (ai:wait 'unit-peasant)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<a name="ai:wait-force"></a>
<h3>(ai:wait-force force)</h3>

Wait until a force is complete, the forces are build in force number order.
First 0, than 1, last 9.


<dl>
<dt>force</dt>
<dd>Number of the force to which the units should belong. 0 - 9 is currently
supported.
</dd>
</dl>

<h4>Example</h4>

<pre>
    ;; Force 0 is build with one footman. The script continues processing, if the
    ;; footman is ready trained.
    (ai:force 0 'unit-footman 1)
    (ai:wait-force 0)
</pre>

<h4>Used</h4>

<a href="../../data/ccl/ai.ccl"> $LIBARYPATH/ccl/ai.ccl </a>

<h2>Notes</h2>

The current AI script support is very limited, many new functions are needed.
If you want to write this you know who to contact.

<h2>Examples</h2>

<pre>
(define-ai "wc2-example" 'orc 'land-attack
</pre><p style="margin-left:1cm;">
This is the AI "wc2-example" usable for human race and land-attack.
</p><pre>
  '( (ai:need (unit-type 'unit-great-hall))
</pre><p style="margin-left:1cm;">
The first need unit is the great-hall.
</p><pre>
     (ai:need 'unit-peon)
</pre><p style="margin-left:1cm;">
The next unit should be the peon.
</p><pre>
     (ai:wait 'unit-great-hall)
</pre><p style="margin-left:1cm;">
Now wait until the great hall is available. Could hang if no great hall can be
build.
</p><pre>
     (ai:wait 'unit-peon) ))
</pre><p style="margin-left:1cm;">
Now wait unit we have a worker to build the next things.
</p>

FIXME: need some complex examples.

<hr>
Last changed: $Id$<br>
All trademarks and copyrights on this page are owned by their respective owners.
<address>(c) 2002-2003 by <a href="http://stratagus.org">
The Stratagus Project</a></address></body></html>
