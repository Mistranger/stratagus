
$Id$

INTRODUCTION

This is a 2-level hierarchical pathfinder currently based on A* algorithm
(although it might be worth it to consider changing one or the other level
to another type of algorithm - see DISCUSSION bellow). It works by dividing
the map into regions and searching path through the region graph first.
The lower half of the pathfinder (which operates conventionally on map tiles)
is then restricted to tiles belonging to regions lying along the path found
by the higher half.

OVERVIEW

The map is divided to Regions. A region is a fully connected graph of map
tiles. In other words, a region is a set of map tiles such that path between
any two tiles belonging to the region exists and lies within the region.

If the regions are to be useful for pathfinding, they shouldn't be too big.
That's why the above mentioned definition of region has to be extended.
Otherwise on most maps we could end up with only a handful of huge regions
that are unusable for pathfinding purposes.

So we will require that a region lies entirely within a single Area. An
area is a usually square (but in principle, this is not required) portion
of map.  E.g. a 512x512 map could be divided into 32x32 square areas (each
area has 16x16 tiles). During initial processing of the map, we take one
area after another and find all fully connected sets of tiles within them.
These sets of tiles become regions.

Next step is finding each region's neighbors. Two regions are neighbors if
a path exists between them that lies entirely within them. It follows from
definition of a region that boundary between two regions can only be
identical to area boundary (two regions cannot be neighbors *inside* of an
area - that would mean that they are really a single region).

Example:
-------

The following 16x8 map

XXX......XXXX...
XX...XX..XXX..XX       X - blocked
XX....X..XX..XXX       . - free
X...XXX...X..XXX
.....XXX.XXXXXXX
X..........XX...
XXX............X
XXXXX....X....XX


would be broken into areas and regions like this:


XXX1 2222 3XXX X555
XX11 2XX2 3XXX 55XX    X     - blocked
XX11 22X2 3XX4 5XXX    [0-9] - region number
X111 XXX2 33X4 5XXX

6666 7XXX 8XXX XXXX
X666 7777 888X X999
XXX6 7777 8888 999X
XXXX X777 8X88 99XX


Note that area (2,0) contains more than one region.

Region neighbor lists would be initialized as follows:

region 1: neighbors 2, 6, 7
region 2: neighbors 1, 3
region 3: neighbors 2, 8
region 4: neighbors 5
region 5: neighbors 4
region 6: neighbors 1, 7
region 7: neighbors 6, 8, 1
region 8: neighbors 7, 9, 2
region 9: neighbors 8

The region neighborship information forms a graph that is traversed by higher
level portion of the pathfinder. The higher level portion produces a region
path. E.g. if we searched a path from (3,1) to (7,0) the region path would
be (1, 2, 3). The lower level algorithm then ignores (i.e. never puts on
Open) tiles not belonging to one of those 3 regions.


IMPLEMENTATION NOTES

Every region has its descriptor (struct _region_ ) which contains its
unique Region Id (regid). Each map tile contains regid of the region to
which it belongs. Regions are stored in an AVL-tree (regid used as key) for
fast lookup. Overhead of the tree should be negligible here as regions are
not very often added of deleted. Region descriptor also contains an array
of pointers to neighboring regions, flags field which indicates whether the
region is on the Open or Close set, a pointer to a parent region and a
couple of integer attribs that hold A* values (f, g, h).

Several parts of the hierarchical algorithm use region bitmaps for faster
lookup. These are bit arrays where every regid is allocated the regid-th
bit. E.g. bit 0 belongs to regid 0, bit 2543 belongs to regid 2543. This is
quite fast but if the regids for new regions (created by map changes like
forest removal etc. during the game) were not allocated carefully the
bitmaps could get big and sparse. That's why this implementation includes
regid management code that reuses regids and generally avoids framentation
of regid space, thus compressing region bitmaps.

DISCUSSION

I suspect there might be a situation where A*'s overhead is not worth the
trouble. E.g. if you use 16x16 areas on a 128x128 map the higher level
pathfinder operates on a 8x8 grid (OK, the number of actual regions will
probably be higher but you get the idea) which is so small that breadth-first
algorithm's inefficiency cannot do much harm and you can get rid of A*'s
overhead (mostly the priority queue). Or if you use 4x4 areas it might be
worth giving a try to convert the lowlevel portion of the pathfinder to
breadth-first. With such a small area size the lowlevel pathfinder is
"channeled" so narrowly that again, breadth-first algorithm's inefficiency
might not come into play.

